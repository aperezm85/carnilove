---
import FAQ from "@/components/FAQ.astro";
import Feed from "@/components/Feed.astro";
import FindYourPath from "@/components/FindYourPath.astro";
import FromTheWild from "@/components/FromTheWild.astro";

import Hero from "@/components/Hero/Hero.astro";
import Ingredients from "@/components/Ingredients.astro";
import Instincts from "@/components/Instincts.astro";
import ShopProduct from "@/components/ShopProduct.astro";
import Trusted from "@/components/Trusted.astro";
import Layout from "@/layouts/Layout.astro";
---

<Layout>
  <section
    id="savannah"
    class="fixed inset-0 pointer-events-none z-2 opacity-0 top-[50%]"
    style="background-image: url('/savannah-large.png'); background-size: cover; background-position: center bottom;"
  >
  </section>
  <section
    id="rocks"
    class="fixed inset-0 pointer-events-none z-2 opacity-0 top-[50%]"
    style="background-image: url('/rock-and-grass.png'); background-size: cover; background-position: center bottom;"
  >
  </section>
  <section
    id="forest"
    class="fixed inset-0 pointer-events-none z-2 opacity-0 top-[0%]"
    style="background-image: url('/forest.png'); background-size: cover; background-position: center bottom;"
  >
  </section>

  <Hero />
  <ShopProduct />
  <Feed />
  <Instincts />
  <Ingredients />
  <FindYourPath />
  <Trusted />
  <FromTheWild />
  <FAQ />
</Layout>

<script>
  import { gsap } from "gsap";
  import { ScrollToPlugin } from "gsap/ScrollToPlugin";
  import { ScrollTrigger } from "gsap/ScrollTrigger";
  import { SplitText } from "gsap/SplitText";

  gsap.registerPlugin(ScrollTrigger, SplitText, ScrollToPlugin);

  document.querySelectorAll(".pin-section");

  const sections: HTMLElement[] = gsap.utils.toArray(".pin-section");

  // this scrolling object just allows us to conveniently call scrolling.enable(), scrolling.disable(), and check if scrolling.enabled is true.
  // some browsers (like iOS Safari) handle scrolling on a separate thread and can cause things to get out of sync (jitter/jumpy), so when we're animating the scroll position, force an update of GSAP tweens when there's a scroll event in order to maintain synchronization)
  const scrolling = {
    enabled: true,
    events: "scroll,wheel,touchmove,pointermove".split(","),
    prevent: (e: Event) => e.preventDefault(),
    disable() {
      if (scrolling.enabled) {
        scrolling.enabled = false;
        window.addEventListener("scroll", gsap.ticker.tick, { passive: true });
        scrolling.events.forEach((e, i) =>
          (i ? document : window).addEventListener(e, scrolling.prevent, {
            passive: false,
          })
        );
      }
    },
    enable() {
      if (!scrolling.enabled) {
        scrolling.enabled = true;
        window.removeEventListener("scroll", gsap.ticker.tick);
        scrolling.events.forEach((e, i) =>
          (i ? document : window).removeEventListener(e, scrolling.prevent)
        );
      }
    },
  };

  function goToSection(section: HTMLElement) {
    if (scrolling.enabled) {
      // skip if a scroll tween is in progress
      scrolling.disable();
      gsap.to(window, {
        scrollTo: { y: section, autoKill: false },
        onComplete: scrolling.enable,
        duration: 1.5,
      });
    }
  }

  // ----- New coordinated scroll handling that calls section.playLeave/playEntry -----
  // Keep `isAnimating` here in the parent and call child-exposed promises for entry/leave.
  function findCurrentIndex() {
    const yCenter = window.scrollY + window.innerHeight / 2;
    for (let i = 0; i < sections.length; i++) {
      const rect = sections[i].getBoundingClientRect();
      const top = window.scrollY + rect.top;
      const bottom = top + rect.height;
      if (yCenter >= top && yCenter < bottom) return i;
    }
    return 0;
  }

  let currentIndex = findCurrentIndex();
  let isAnimating = false;
  const numSections = sections.length;

  function animateToSectionIndex(targetIndex: number) {
    if (targetIndex < 0 || targetIndex >= numSections)
      return Promise.reject("out-of-bounds");
    const targetSection = sections[targetIndex];
    return new Promise<void>((resolve) => {
      gsap.to(window, {
        scrollTo: { y: targetSection, autoKill: false },
        duration: 1.2,
        ease: "power2.inOut",
        onComplete: () => resolve(),
        onInterrupt: () => resolve(),
      });
    });
  }

  function handleWheel(event: WheelEvent) {
    if (isAnimating) {
      event.preventDefault();
      return;
    }
    const delta = event.deltaY;
    if (Math.abs(delta) < 5) return;
    event.preventDefault();

    const direction = delta > 0 ? 1 : -1;
    const targetIndex = currentIndex + direction;
    if (targetIndex < 0 || targetIndex >= numSections) return;

    isAnimating = true;
    const currentSection: any = sections[currentIndex];
    const newSection: any = sections[targetIndex];

    const leavePromise =
      typeof currentSection.playLeave === "function"
        ? currentSection.playLeave()
        : Promise.resolve();

    Promise.resolve(leavePromise)
      .then(() => animateToSectionIndex(targetIndex))
      .then(() => {
        currentIndex = targetIndex;
        return typeof newSection.playEntry === "function"
          ? newSection.playEntry()
          : Promise.resolve();
      })
      .then(() => {
        isAnimating = false;
      })
      .catch((err) => {
        console.error("Scroll animation error:", err);
        isAnimating = false;
      });
  }

  window.addEventListener("wheel", handleWheel, { passive: false });

  // Initial entry for the first section (if it exposes playEntry)
  if (sections[0]) {
    const first: any = sections[0];
    if (typeof first.playEntry === "function") {
      isAnimating = true;
      Promise.resolve(first.playEntry())
        .then(() => {
          isAnimating = false;
        })
        .catch(() => {
          isAnimating = false;
        });
    }
  }

  // -------------------------------------------------------------------------------

  const savannah = document.getElementById("savannah");
  const rocks = document.getElementById("rocks");
  const forest = document.getElementById("forest");
  const shopSection = document.getElementById("shop-by-product");
  const feed = document.getElementById("feed-their-nature");

  if (savannah && rocks && forest && shopSection && feed) {
    // Timeline for bottom transitions
    // Give each step an explicit duration so the ScrollTrigger maps each tween
    // evenly across the scroll span. Without explicit durations the timeline
    // can end up unevenly distributed which makes the first tween only reach
    // a fraction of its target (e.g. opacity ~0.1588).
    const bgTimeline = gsap.timeline({
      defaults: { duration: 0.5 },
      scrollTrigger: {
        trigger: "#shop-by-product",
        start: "top center",
        end: "bottom bottom",
        endTrigger: "#trusted",
        scrub: 1,
      },
    });
    bgTimeline
      // Fade in and start from bottom
      .fromTo(
        savannah,
        { opacity: 0, backgroundPositionY: "0%", ease: "none" },
        {
          duration: 0.05,
          opacity: 0.6,
          backgroundPositionY: "85%",
          ease: "none",
        }
      )
      // Move higher during section 3
      .to(savannah, {
        opacity: 1,
        backgroundPositionY: "30%",
        ease: "none",
      })
      // Move down during section 4
      .to(savannah, {
        backgroundPositionY: "40%",
        ease: "none",
      })
      // Fade out at section 5
      .to(savannah, {
        backgroundPositionY: "60%",
        ease: "none",
      })
      // Fade out at section 6
      .to(savannah, {
        backgroundPositionY: "80%",
        ease: "none",
      })
      // Fade out at section 7
      .to(savannah, {
        opacity: 0,
        ease: "none",
      });
  }

  const rocksTimeline = gsap.timeline({
    defaults: { duration: 0.5 },
    scrollTrigger: {
      trigger: "#instincts",
      start: "top center",
      end: "top top",
      endTrigger: "#trusted",
      scrub: 1,
    },
  });

  rocksTimeline
    .fromTo(
      rocks,
      {
        opacity: 0,
        backgroundPositionY: "0%",
      },
      {
        opacity: 1,
        duration: 0.05,
        backgroundPositionY: "100%",
        ease: "none",
      }
    )
    .to(rocks, {
      backgroundPositionY: "80%",
      ease: "none",
    })
    .to(rocks, {
      backgroundPositionY: "100%",
      ease: "none",
    })
    .to(rocks, {
      opacity: 0,
      ease: "none",
    });

  const forestTimeline = gsap.timeline({
    scrollTrigger: {
      trigger: "#trusted",
      start: "top bottom",
      end: "bottom bottom",
      endTrigger: "#FAQ",
      scrub: 1,
    },
  });

  forestTimeline
    .fromTo(
      forest,
      {
        opacity: 0,
        backgroundPositionY: "0%",
      },
      {
        opacity: 1,
        backgroundPositionY: "85%",
        ease: "none",
      }
    )
    .to(forest, {
      backgroundPositionY: "30%",
      ease: "none",
    })
    .to(forest, {
      opacity: 0,
      ease: "none",
    });
</script>
